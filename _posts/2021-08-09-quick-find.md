---
layout: post
title: 惨不忍睹的算法的开始
categories: [技术]
tags: [算法, 学而]
lang: zh-hans
---

最近又开始捣鼓算法了，我是想好好研究研究算法，打好面试的基础，准备两年后跑路的。
没想到第一个快速查找就把我打击到了。

快速查找的算法是用来快速的检测两个对象是否连接在一起的。当我们把两个对象连接起来的时候，就把对象的值改成相同值，这样，当判断两个对象是否相等的时候，就直接判断对象的值是否相等。

为了简单，我们把对象存放在一个数组里面，并用跟索引值相等的整型值来代表对象。

这样就有一个原始的数据结构,以10个举例。

```
int[] id = new int[10];
for(int i = 0; i < 10; i++){
    id[i] = i;
}
```

连接方法的实现，是要把数组的对象改成相同的值。对于从来没有跟其他对象连接过的对象来说，只要把后面的值改成前面的值就可以了。
但是对于已经连接过的其他的对象来说，要把所有的其他对象都改成相同的值。

比如，下面的数组就表示0，1和1，3都连接过。

```[0，0，2，0，4，5，6，7，8，9]```

接下来要连接8，9和7，8的时候，如果只是把后面的值改成前面的值就会变成这样：

```[0，0，2，0，4，5，6，7，8，8]```
```[0，0，2，0，4，5，6，7，7，8]```

缺少了把其他相同连接值改变的步骤。

```[0，0，2，0，4，5，6，7，7，7]```

我就在这时犯了一个错误，原本只要把所有不同的连接值改变成为相同的值就可以，比如：

```[0，0，2，0，4，5，6，7，7，7]```

或者

```[0，0，2，0，4，5，6，9，9，9]```

这里，我错误地运用了一个策略，那就是要找打两个连接的大多数值，然后把较少的值改为大多数值。
其实这是不需要的，因为连接只要保证值相等就可以了，无论是改多数值还是少数值，都是一样的结果，而且都不会有数值碰撞的。

我为什么会这样想呢？其实最先浮现在我脑海的是服务器的主从更新策略，我也想到了要是两组连接个数相等时应该怎么办，但是没有仔细想，所以就错过了这个重要策略错误推断。下次再又什么灵光一闪的时候不要错过，多想想。

学而时习之，不亦说乎。

