---
layout: post
title: 继续捣鼓算法
categories: [技术]
tags: [算法, 学而, TODO]
lang: zh-hans
---

这次算是有点入门了，经过上次惨不忍睹的算法开始。

快速连接算法讲的是，当把两个节点连接起来的时候，直接把一个节点的值改为另一个节点的索引值。

初始还是一个数组，并用跟索引值相等的整型值来代表对象。

这样就有一个原始的数据结构,以10个举例。

```
int[] id = new int[10];
for(int i = 0; i < 10; i++){
    id[i] = i;
}
```
初始数组

```[0，1，2，3，4，5，6，7，8，9]```

当连接0，1时，把0的值改为1，表示0的父节点是1

```[1，1，2，3，4，5，6，7，8，9]```

继续连接3，5和5，8，

```[1，1，2，5，4，5，6，7，8，9]```
```[1，1，2，5，4，8，6，7，8，9]```

当我们找一个节点的父节点时，要一直找节点值对应的索引位置的值，直到节点值等于索引值。

比如3的父节点是5，5的父节点是8，8的父节点是8。8==8，这样就表示8没有父节点了。

自己实现的时候跟教程的差别是查找父节点的实现，我用了递归，教程使用的是循环。

这是思维差距，还是其他的原因导致的呢？递归总能被循环实现，但是递归在表现上更容易理解和编写。
//TODO
我应该找时间研究研究递归和循环实现的差异和好坏。

这是没有权重的连接方法，当我连接两个节点时，只是把一个节点直接连接到另一个节点上，并不在乎两个节点哪个比较大。
权重的连接方法，在连接的时候，会比较两个节点树的元素多少，把小的节点树连接到大的节点书上。

这个权重的实现是在连接方法里实现的，我们初始话一个n个元素为1的数组，当把节点a连接到节点b上时，索引a的权重数组值要加上索引b的权重数组值。
相等的时候就前一个移到后一个的节点上。
